<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeMatrix</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-25T13:27:36.553Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>jrliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/04/25/HashMap%E4%B8%8EHashSet/"/>
    <id>http://yoursite.com/2019/04/25/HashMap与HashSet/</id>
    <published>2019-04-25T13:27:36.553Z</published>
    <updated>2019-04-25T13:27:36.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初探HashSet-and-HashMap"><a href="#初探HashSet-and-HashMap" class="headerlink" title="初探HashSet and HashMap"></a>初探HashSet and HashMap</h1><h2 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1.总体介绍"></a>1.总体介绍</h2><p> HashSet和HashMap在Java里有着相同的实现，前者仅仅是对后者做了一层包装。因此本文将重点分析HashMap。HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素(注意HashTable不可以)；除该类未实现同步外（HashTable支持），其余跟Hashtable大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。Java HashMap采用的是冲突链表方式。<br><img src="en-resource://database/695:1" alt="b7109b21c593d0af05ff7e1301a8a14a.png"></p><p>从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。将对象放入到HashMap或HashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需重载hashCode()和equals()方法。</p><h2 id="2-方法剖析"><a href="#2-方法剖析" class="headerlink" title="2.方法剖析"></a>2.方法剖析</h2><p>get()<br>get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初探HashSet-and-HashMap&quot;&gt;&lt;a href=&quot;#初探HashSet-and-HashMap&quot; class=&quot;headerlink&quot; title=&quot;初探HashSet and HashMap&quot;&gt;&lt;/a&gt;初探HashSet and HashMap&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hello-hex</title>
    <link href="http://yoursite.com/2019/04/24/hello-hex/"/>
    <id>http://yoursite.com/2019/04/24/hello-hex/</id>
    <published>2019-04-23T16:24:57.000Z</published>
    <updated>2019-04-23T16:24:57.669Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
